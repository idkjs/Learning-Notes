# Computer Science

**https://github.com/PharkMillups/beautiful-docs/**

* [10,000 times faster than MySQL?](https://brigade.engineering/10-000-times-faster-than-mysql-7296389e74bb#.kw0f0r6ce)
* [Learn X in Y](https://learnxinyminutes.com/)
* [I built an app that makes learning algorithms and data structures way more fun](https://medium.freecodecamp.org/i-built-an-app-that-makes-learning-algorithms-and-data-structures-way-more-fun-46fbb8afacaf)
* [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
* [VisuAlgo](https://visualgo.net/en)

## Big O

* [Time Complexity/Big O Notation](https://medium.com/javascript-scene/time-complexity-big-o-notation-1a4310c3ee4b#.jhucyh6v5)
* [Big-O notation explained by a self-taught programmer](https://justin.abrah.ms/computer-science/big-o-notation-explained.html)
* [Know Thy Complexities!](http://bigocheatsheet.com/)

The gist is that algorithms can take more or less time, depending on their complexity, which is ranked in this order: O(1), O(log n), O(n), O(n log(n)), O(n^2), O(2^n), O(n!). So, we prefer searches to be in one of the classifications at the beginning of this list.

## Sorting

* [Quicksort](http://me.dt.in.th/page/Quicksort/)
* [On Iteration](http://www.informit.com/articles/article.aspx?p=1407357&seqNum=3)
* [Counting Linearly With Counting Sort](https://medium.com/basecs/counting-linearly-with-counting-sort-cd8516ae09b3)
* [Sorting Algorithms resources](https://github.com/no-stack-dub-sack/cs-playground-react/blob/master/RESOURCES.md)

## Searching

### Binary Search

* [Building a Binary Search](https://fluxusfrequency.github.io/blog/2014/01/31/building-a-binary-search/) 

## Bellman-Ford Algorithm

## Dijkstra's Algorithm